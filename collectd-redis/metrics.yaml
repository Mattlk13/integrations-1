bytes.used_memory:
  brief: Number of bytes allocated by Redis
  description: '> used_memrory: total number of bytes allocated by Redis using its
    allocator (either standard libc, jemalloc, or an alternative allocator such as
    tcmalloc

    Use this metric to see how much memory Redis is taking.'
  metric_type: gauge
  title: Used Memory

bytes.used_memory_lua:
  brief: Number of bytes used by the Lua engine
  description: '> used_memory_lua: Number of bytes used by the Lua engine

    Use this metric to see how much memory the Lua engine within Redis is taking.'
  metric_type: gauge
  title: Used Memory by Lua

bytes.used_memory_peak:
  brief: Peak Number of bytes allocated by Redis
  description: '> used_memory_peak: Peak memory consumed by Redis (in bytes)

    Use this metric to see the max memory Redis has taken since it last started.'
  metric_type: gauge
  title: Used Memory Peak

bytes.used_memory_rss:
  brief: Number of bytes allocated by Redis as seen by the OS
  description: '> used_memory_rss: Number of bytes that Redis allocated as seen by
    the operating system (a.k.a resident set size). This is the number reported by
    tools such as top(1) and ps(1)

    Use this metric to see how much memory Resident memory Redis is taking.'
  metric_type: gauge
  title: Used Memory Resident Set Size

counter.commands_processed:
  brief: Total number of commands processed by the server
  description: '> commands_processed: Total number of commands processed by the server

    Use this metric to see how many commands are processed by a particular server.'
  metric_type: cumulative
  title: Commands Processed

counter.connections_received:
  brief: Total number of connections accepted by the server
  description: '> Total number of connections accepted by the server

    Use this metric to see how many connections are accepted by a particular server.'
  metric_type: cumulative
  title: Connections Received

counter.evicted_keys:
  brief: Number of evicted keys due to maxmemory limit
  description: '> evicted_keys: Number of evicted keys due to maxmemory limit

    Use this metric to see how many keys are evicted due to hitting the maxmemory
    limit.

    If this metric is significantly different than other servers:

    * Maxmemory limit may be too low'
  metric_type: cumulative
  title: Evicted Keys

counter.expired_keys:
  brief: Total number of key expiration events
  description: '> expired_keys: Total number of key expiration events

    Use this metric to see how many keys are expired.'
  metric_type: cumulative
  title: Expired Keys

counter.lru_clock:
  brief: Clock incrementing every minute, for LRU management
  description: '> lru_clock: Clock incrementing every minute, for LRU management.'
  metric_type: cumulative
  title: LRU Clock

counter.rejected_connections:
  brief: Number of connections rejected because of maxclients limit
  description: '> rejected_connections: Number of connections rejected because of
    maxclients limit

    Use this metric to see how many connections are rejected by a particular server.

    If this metric is significantly different than other servers:

    * Macclients limit set too low'
  metric_type: cumulative
  title: Rejected Connections

counter.total_net_input_bytes:
  brief: Total number of bytes inputted
  description: '> total_net_input_bytes: Total number of bytes inputted

    Total number of bytes inputted.'
  metric_type: cumulative
  title: Total Input Bytes

counter.total_net_output_bytes:
  brief: Total number of bytes outputted
  description: '> total_net_output_bytes: Total number of bytes outputted

    Total number of bytes outputted.'
  metric_type: cumulative
  title: Total Output Bytes

counter.used_cpu_sys:
  brief: System CPU consumed by the Redis server
  description: '> used_cpu_sys: System CPU consumed by the Redis server

    Use this metric to see how much cpu is being consumed by Redis.'
  metric_type: cumulative
  title: Used System CPU

counter.used_cpu_sys_children:
  brief: System CPU consumed by the background processes
  description: '> used_cpu_sys_children: System CPU consumed by the background processes

    Use this metric to see how much cpu is being consumed by Redis background processes.'
  metric_type: cumulative
  title: Used System CPU Children

counter.used_cpu_user:
  brief: User CPU consumed by the Redis server
  description: '> used_cpu_user: User CPU consumed by the Redis server

    Use this metric to see how much user cpu is being consumed by Redis.'
  metric_type: cumulative
  title: User CPU Used

counter.used_cpu_user_children:
  brief: User CPU consumed by the background processes
  description: '> used_cpu_user_children: User CPU consumed by the background processes

    Use this metric to see how much user cpu is being consumed by Redis background
    processes.'
  metric_type: cumulative
  title: Used User CPU children

derive.keyspace_hits:
  brief: Number of successful lookup of keys in the main dictionary
  description: '> keyspace_hits: Number of successful lookup of keys in the main dictionary.'
  metric_type: cumulative
  title: Keyspace Hits

derive.keyspace_misses:
  brief: Number of failed lookup of keys in the main dictionary
  description: '> keyspaces_misses: Number of failed lookup of keys in the main dictionary.'
  metric_type: cumulative
  title: Keyspace Misses

gauge.blocked_clients:
  brief: Number of clients pending on a blocking call
  description: '> blocked_clients: Number of clients pending on a blocking call (BLPOP,
    BRPOP, BRPOPLPUSH)

    Use this metric to see how many clients are pending on blocking calls.'
  metric_type: gauge
  title: Blocked Clients

gauge.changes_since_last_save:
  brief: Number of changes since the last dump
  description: '> changes_since_last_save: Number of changes since the last dump

    Use this metric to see any changes since the last dump.'
  metric_type: gauge
  title: Changes since last save

gauge.client_biggest_input_buf:
  brief: Biggest input buffer among current client connections
  description: '> client_biggest_input_buf: biggest input buffer among current client
    connections

    Use this metric to see which client conets contains the biggest input buffer.'
  metric_type: gauge
  title: Client largest input buffer

gauge.client_longest_output_list:
  brief: Longest output list among current client connections
  description: '> client_longest_output_list: Longest output list among current client
    connections

    Use this metric to see which among the current client connections is the longest.'
  metric_type: gauge
  title: Longest client output list

gauge.connected_clients:
  brief: Number of client connections (excluding connections from slaves)
  description: '> connected_clients: Number of client connections (excluding connections
    from slaves)

    Use this metric to see how many clients are connected not including slaves.'
  metric_type: gauge
  title: Connected clients

gauge.connected_slaves:
  brief: Number of connected slaves
  description: '> connected_slaves: Number of connected slaves

    Use this metric to see how many slaves are connected.

    If this metric is significantly different than other servers:

    * Perhaps unbalanced master/slave ratio'
  metric_type: gauge
  title: Connected slaves

gauge.db0_avg_ttl:
  brief: The average time to live for all keys in redis
  description: '> gauge.db0_avg_ttl : The average time to live for all keys in redis'
  metric_type: gauge
  title: Average TTL

gauge.db0_expires:
  brief: The total number of keys in redis that will expire
  description: '> gauge.db0_expires : The total number of keys stored in redis that
    wil expire'
  metric_type: gauge
  title: Number of keys that will expire

gauge.db0_keys:
  brief: The total number of keys stored in redis
  description: '> gauge.db0_keys : The total number of keys stored in redis'
  metric_type: gauge
  title: Number of keys

gauge.instantaneous_ops_per_sec:
  brief: Number of commands processed per second
  description: '> instantaneous_ops_per_sec: Number of commands processed per second

    Use this metric to see how fast commands are being processed.'
  metric_type: gauge
  title: Instantaneous Operatons per second

gauge.key_llen:
  brief: Length of an list key
  description: '> gauge.key_llen : Length of an list key'
  metric_type: gauge
  title: Key LLEN

gauge.latest_fork_usec:
  brief: Duration of the latest fork operation in microseconds
  description: '> latest_fork_usec: Duration of the latest fork operation in microseconds

    Use this metric to see how fast fork operatios are.

    If this metric is significantly different than other servers:

    * This server could be overloaded'
  metric_type: gauge
  title: Latest fork time

gauge.master_last_io_seconds_ago:
  brief: Number of seconds since the last interaction with master
  description: '> master_last_io_seconds_ago: Number of seconds since the last interaction
    with master

    Use this metric to see how long this slave last interacted with master.'
  metric_type: gauge
  title: Last IO with master

gauge.master_repl_offset:
  brief: Master replication offset
  description: '> master_repl_offset: target offset of master dataset

    Use this metric to and compare with slave_repl_offset on slaves to figure out
    how replication is doing.  if slave_repl_offset on slave host is behind its  master''s
    master_repl_offset, you know you have a replication problem.'
  metric_type: gauge
  title: Master replication offset

gauge.mem_fragmentation_ratio:
  brief: Ratio between used_memory_rss and used_memory
  description: '> mem_fragmentation_ratio: Ratio between used_memory_rss and used_memory

    Ideally, the used_memory_rss value should be only slightly higher than used_memory.
    When rss >> used, a large difference means there is memory fragmentation (internal
    or external), which can be evaluated by checking mem_fragmentation_ratio. When
    used >> rss, it means part of Redis memory has been swapped off by the operating
    system: expect some significant latencies.'
  metric_type: gauge
  title: Memory fragmentation ratio

gauge.rdb_bgsave_in_progress:
  brief: Flag indicating a RDB save is on-going
  description: '> rdb_bgsave_in_progress: Flag indicating a RDB save is on-going

    Use this metric to see if a save is ongoing.'
  metric_type: gauge
  title: RDB BG save in progress

gauge.repl_backlog_first_byte_offset:
  brief: Slave replication backlog offset
  description: '> repl_backlog_first_byte_offset: Slave replication backlog offset

    Compare with master_repl_offset to see how replication is doing.'
  metric_type: gauge
  title: Slave replication backlog offset

gauge.slave_repl_offset:
  brief: Slave replication offset
  description: '> slave_repl_offset: How much has the slave replicated

    Use this metric to and compare with master_repl_ofset on masters to figure out
    how replication is doing.

    If this metric is significantly different than master:

    * There could be a replications problem'
  metric_type: gauge
  title: Slave replication offset

gauge.uptime_in_days:
  brief: Number of days up
  description: '> uptime_in_days: Number of days up

    Use this metric to see how long redis has been up in days.'
  metric_type: gauge
  title: Uptime in days

gauge.uptime_in_seconds:
  brief: Number of seconds up
  description: '> uptime_in_seconds: Number of seconds up

    Use this metric to see how long redis has been up in seconds.'
  metric_type: gauge
  title: Uptime in seconds

